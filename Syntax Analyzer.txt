package SyntaxAnalyzer;

import javax.swing.JTree;
import javax.swing.tree.DefaultMutableTreeNode;

public class SyntaxAnalyzer {

	//Next token to follow
	Token nextToken = null;

	//Components needed to build parse tree
	JTree parseTree = null;
	DefaultMutableTreeNode nodeProgram = null;
	DefaultMutableTreeNode nodeStatement = null;
	DefaultMutableTreeNode nodeDeclarationStatement = null;
	DefaultMutableTreeNode nodeAssignmentStatement = null;
	DefaultMutableTreeNode nodeExpressionStatement = null;
	DefaultMutableTreeNode nodeIfStatement = null;
	DefaultMutableTreeNode nodeWhileStatement = null;
	DefaultMutableTreeNode nodeBooleanStatement = null;
	DefaultMutableTreeNode nodeTerm = null;
	DefaultMutableTreeNode nodeFactor = null;
	DefaultMutableTreeNode nodeLeaf = null;

	//Lexer 
	LexicalAnalyzer LA = null;

	/*
	 * Constructor
	 */
	SyntaxAnalyzer(String fileName){

		// Initialize the lexical analyzers;
		LA = new LexicalAnalyzer(fileName);

	}

	/*
	 * Function returnParseTree
	 * Return the parseTree created by the Analyzer
	 */
	public JTree getParseTree(){
		parseTree = new JTree(nodeProgram);
		return this.parseTree;
	}

	/*
	 * Function program --> Main parsing beings here!
	 * Parses string in the language generated by the rule
	 * <program> -> <statement> { ; <statement> }
	 */
	public void program(){
		System.out.println("Entered Program");

		//Create the main tree node called Program
		nodeProgram = new DefaultMutableTreeNode("Program");

		//Start of analysis
		nextToken = LA.lex();
		statement(nodeProgram);

		while(nextToken.getType() == Token.T_SEMICOLON){
			nextToken = LA.lex();
			if(nextToken.getType() == Token.T_EOF) break;
			statement(nodeProgram);
		}
		if(nextToken.getType() != Token.T_EOF){
			SyntaxAnalyzerDemo.showMessage("Statement should end with semicolon (;)");
			return;
		}
		else{
			SyntaxAnalyzerDemo.showMessage("Parsing complete!");
		}
		
		System.out.println("Exited Program");
	}

	/*
	 * Function statement
	 * Parses string in the language generated by the rule
	 * <statement> -> <dec_statement> | <assign_statement> | <if_statement> | <while_statement>
	 */
	void statement(DefaultMutableTreeNode parent){
		System.out.println("Entered Statement");
		/* 
		 * Create the statement Node
		 */
		nodeStatement = new DefaultMutableTreeNode("Statement");
		parent.add(nodeStatement);

		switch(nextToken.getType()){

		case Token.T_INT:
		case Token.T_FLOAT:
			nextToken = LA.lex();
			decleration_statement(nodeStatement);
			break;

		case Token.T_IDENTIFIER:
			nextToken = LA.lex();
			assignment_statement(nodeStatement);
			break;

		case Token.T_IF_KEYWORD:
			nextToken = LA.lex();
			if_statement(nodeStatement);
			break;

		case Token.T_WHILE_KEYWORD:
			nextToken = LA.lex();
			while_statement(nodeStatement);
			break;
			
		default:
			parent.remove(nodeStatement);
			SyntaxAnalyzerDemo.showMessage("Syntax Analyzer: Illegal statement found!");
			//return;
		}

		System.out.println("Exited Statement");
	}

	/*
	 * Function while statement
	 * Parses string in the langauge generated by the rule
	 * <while_stmt> -> while ( <boolean_expr> ) { <statement> {; <statement>} }
	 */
	void while_statement(DefaultMutableTreeNode parent){
		System.out.println("Entered While");
		/*
		 * Create node for while statement
		 */
		nodeWhileStatement = new DefaultMutableTreeNode("While Statement");
		parent.add(nodeWhileStatement);

		if(nextToken.getType() == Token.T_OPENROUNDBRACKET){

			nextToken = LA.lex();
			booleanExpression_Statement(nodeWhileStatement);

			if(nextToken.getType() == Token.T_CLOSEROUNDBRACKET){

				nextToken = LA.lex();
				if(nextToken.getType() == Token.T_OPENCURLYBRACKET){

					nextToken = LA.lex();
					statement(nodeWhileStatement);

					while(nextToken.getType() == Token.T_SEMICOLON){
						nextToken = LA.lex();
						if(nextToken.getType() == Token.T_CLOSECURLYBRACKET) break;
						statement(nodeWhileStatement);
					}

					if(nextToken.getType() == Token.T_CLOSECURLYBRACKET){
						nextToken = LA.lex();
						//return;
					}
					else{
						SyntaxAnalyzerDemo.showMessage("Expected a '}' after statements");
					}

				}
				else{
					SyntaxAnalyzerDemo.showMessage("Expected a '{' before statements");
				}
			}
			else{
				SyntaxAnalyzerDemo.showMessage("Expected a ')' after expression");
			}
		}
		else{
			SyntaxAnalyzerDemo.showMessage("Expected a '(' before expression");
		}

		System.out.println("Exited while");
	}
	/*
	 * Function if_statement
	 * Parses string in the language generated by the rule
	 * <if_stmt> -> if ( <expr_statement> ) { <statement> {; <statement> } }
	 */
	void if_statement(DefaultMutableTreeNode parent){
		System.out.println("Entered If");
		/*
		 * Create a if statement node
		 */
		nodeIfStatement = new DefaultMutableTreeNode("If Statement");
		parent.add(nodeIfStatement);

		if(nextToken.getType() == Token.T_OPENROUNDBRACKET){

			nextToken = LA.lex();
			booleanExpression_Statement(nodeIfStatement);

			if(nextToken.getType() == Token.T_CLOSEROUNDBRACKET){

				nextToken = LA.lex();
				if(nextToken.getType() == Token.T_OPENCURLYBRACKET){

					nextToken = LA.lex();
					statement(nodeIfStatement);

					while(nextToken.getType() == Token.T_SEMICOLON){
						nextToken = LA.lex();
						if(nextToken.getType() == Token.T_CLOSECURLYBRACKET) break;
						statement(nodeIfStatement);
					}
					
					if(nextToken.getType() == Token.T_CLOSECURLYBRACKET){
						nextToken = LA.lex();
						//return;
					}
					else{
						SyntaxAnalyzerDemo.showMessage("Expected a '}' after statements");
					}
				}
				else{
					SyntaxAnalyzerDemo.showMessage("Expected a '{' before statements");
				}
			}
			else{
				SyntaxAnalyzerDemo.showMessage("Expected a ')' after expression");
			}
		}
		else{
			SyntaxAnalyzerDemo.showMessage("Expected a '(' before expression");
		}
		
		System.out.println("Exited if");
	}
	/*
	 * Function booleanExpressionStatement
	 * Parses the string of the language generated by the rule
	 * <booleanExpression_Stmt> -> <identifier> (>|<) <identifier>
	 */
	void booleanExpression_Statement(DefaultMutableTreeNode parent){
		System.out.println("Entered Boolean");
		/*
		 * Create a node for boolean expression
		 */
		nodeBooleanStatement = new DefaultMutableTreeNode("Boolean Expression");
		parent.add(nodeBooleanStatement);

		if(nextToken.getType() == Token.T_IDENTIFIER){

			nextToken = LA.lex();
			if(nextToken.getType() == Token.T_GREATERTHAN || nextToken.getType() == Token.T_LESSTHAN){

				nextToken = LA.lex();
				if(nextToken.getType() == Token.T_IDENTIFIER || nextToken.getType() == Token.T_FLOAT_NUMBER || nextToken.getType() == Token.T_INT_NUMBER){
					nextToken = LA.lex();
					//return;
				}
				else{
					SyntaxAnalyzerDemo.showMessage("Comparison should be made with Identifer or constant");
				}
			}
			else{
				SyntaxAnalyzerDemo.showMessage("A relational operator '>' or '<' is required!");
			}
		}
		else{
			SyntaxAnalyzerDemo.showMessage("Expected a boolean expression!");
		}
		
		System.out.println("Exited boolean");
	}
	/*
	 * Function declaration_statement
	 * Parses string in the language generated by the rule
	 * <dec_statement> -> <keyword> <identifier>
	 */
	void decleration_statement(DefaultMutableTreeNode parent){
		System.out.println("Entered Declaration");
		/*
		 * Create a node for declaration statement
		 */
		nodeDeclarationStatement = new DefaultMutableTreeNode("Declaration");
		parent.add(nodeDeclarationStatement);

		if(nextToken.getType() == Token.T_IDENTIFIER){
			nextToken = LA.lex();
			//return;
		} else{
			SyntaxAnalyzerDemo.showMessage("Not a valid identifier!");
		}
		
		System.out.println("Exited declaration");
	}

	/*
	 * Function assignment_statement
	 * Parses strings of the langauge generated by the rule
	 * <assign_statement> -> <identifier> = <expr_statement>
	 */
	void assignment_statement(DefaultMutableTreeNode parent){
		System.out.println("Entered Assignment");
		/*
		 * Create a node for assignment statement
		 */
		nodeAssignmentStatement = new DefaultMutableTreeNode("Assignment");
		parent.add(nodeAssignmentStatement);


		if(nextToken.getType() == Token.T_EQUALITYOP){
			nextToken = LA.lex();
			expression_statement(nodeAssignmentStatement);
		}
		else{
			SyntaxAnalyzerDemo.showMessage("Expected a '=' operator!");
		}

		
		System.out.println("Exited Assignment");
	}

	/*
	 * Function expression_statement
	 * Parses string of the langauges generated by the rule
	 * <expr_stmt> -> <term> {(+|-) <term> }
	 */
	void expression_statement(DefaultMutableTreeNode parent){
		System.out.println("Entered Expression");

		/*
		 * Create a node for expression statement
		 */

		nodeExpressionStatement = new DefaultMutableTreeNode("Expression");
		parent.add(nodeExpressionStatement);

		term(nodeExpressionStatement);

		while(nextToken.getType() == Token.T_PLUSOP || nextToken.getType() == Token.T_MINUSOP){
			nodeLeaf = new DefaultMutableTreeNode(nextToken.getValue());
			nodeExpressionStatement.add(nodeLeaf);

			nextToken = LA.lex();
			term(nodeExpressionStatement);
		}
		
		System.out.println("Exited Expression");
	}

	/*
	 * Function term
	 * Parses string of the languages generated by the rule
	 * <term> -> <factor> {(*|/) <factor>}
	 */
	void term(DefaultMutableTreeNode parent){
		System.out.println("Entered Term");

		/*
		 * Create a node for term
		 */

		nodeTerm = new DefaultMutableTreeNode("Term");
		parent.add(nodeTerm);


		factor(nodeTerm);

		while(nextToken.getType() == Token.T_MULOP || nextToken.getType() == Token.T_DIVOP){
			nodeLeaf = new DefaultMutableTreeNode(nextToken.getValue());
			nodeTerm.add(nodeLeaf);

			nextToken = LA.lex();
			factor(nodeTerm);
		}
		
		System.out.println("Exited Term");
	}

	/*
	 * Function term
	 * Parses string of the langauges generated by the rule
	 * <factor> -> conts | <identifier> | <expr_stmt>
	 */
	void factor(DefaultMutableTreeNode parent){
		System.out.println("Entered Factor");
		/*
		 * Create a node for factor
		 */
		nodeFactor = new DefaultMutableTreeNode("Factor");
		parent.add(nodeFactor);


		if(nextToken.getType() == Token.T_FLOAT_NUMBER || nextToken.getType() == Token.T_INT_NUMBER || nextToken.getType() == Token.T_IDENTIFIER){
			/*
			 * Create the leaf
			 */
			nodeLeaf = new DefaultMutableTreeNode(nextToken.getValue());
			nodeFactor.add(nodeLeaf);

			nextToken = LA.lex();
			//return;
		}
		else{
			SyntaxAnalyzerDemo.showMessage("Syntax Analyzer: Invalid assignment made to identifier");
		}
		
		System.out.println("Exited Factor");
	}
}
